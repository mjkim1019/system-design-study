# 11장.  뉴스 피드 시스템 설계

## 📌 들어가기

이번 장에서는 뉴스 피드 시스템 설계 문제를 살펴 볼 것이다. 먼저 뉴스 피드(news feed)란 무엇인가?

페이스북의 도움말 페이지에 따르면 뉴스 피드를 아래와 같이 설명하고 있다.

> *뉴스 피드는 여러분의 홈 페이지 중앙에 지속적으로 업데이트되는 스토리들로, 사용자 상태 정보 업데이트, 사진, 비디오, 링크, 앱 활동(app activity), 그리고 여러분이 페이스북에서 팔로우하는 사람들, 페이지, 또는 그룹으로부터 나오는 ‘좋아요’등을 포함한다*
> 

## 📌 본문

지금까지 진행했던 방법들과 마찬가지로 4단계에 걸쳐서 ‘뉴스 피드 시스템 설계’를 해보도록 하겠다.

## ✅ 1단계. 문제 이해 및 설계 범위 확정

가장 먼저 면접관의 의도와 요구사항을 ‘**질문**’을 통해 파악해야 한다.

(글에서는 아래와 같은 질문&답변 과정을 거쳤다고 가정합니다)

1. 모바일 앱을 위한 시스템인가요? 아니면 웹을 위한 시스템인가요? 혹은 둘 다 지원해야 하나요?
👨‍💻 : 둘 다 지원해야 합니다.
2. 핵심(중요한) 기능은 어떤 것이 있나요?
👨‍💻 : 사용자는 뉴스 피드 페이지에 새로운 스토리를 올릴 수 있어야 하고, 친구들이 올리는 스토리를 볼 수 있어야 합니다.
3. 뉴스 피드는 어떤 순서로 표시되어야 하나요? 최신순인가요? 아니면 특정 score를 부여한 알고리즘이 있나요? 예를 들어 친한 친구에 score를 부여하여 좀 더 위에 배치하는 방식 같은 기준 말입니다.
👨‍💻 : 단순히 시간 흐름 역순(최신순)으로 표시된다고 가정합시다.
4. 한 명의 사용자는 최대 몇 명의 친구를 가질 수 있나요?
👨‍💻 : 5000명입니다.
5. 트래픽 규모는 어느 정도 입니까?
👨‍💻 : 매일 천만 명이 방문한다고 가정합시다.
6. 피드에 이미지나 비디오 스토리도 올라올 수 있나요?
👨‍💻 : 네.

## ✅ 2단계. 개략적 설계안 제시 및 동의 구하기

핵심 기능은 (1) 뉴스 피드에 새로운 스토리 올리기 (2) 뉴스 피드 보기, 이렇게 두 가지다. 따라서 설계안은 (1) 피드 발행(feed publishing)과 (2) 뉴스 피드 생성(news feed building) 두 가지 부분으로 나눌 수 있다.

### 1. 피드 발행

- 사용자가 스토리를 포스팅하면 해당 데이터를 캐시와 데이터베이스에 기록한다. 새 포스팅은 친구의 뉴스 피드에도 전송된다.
- API : `POST /v1/me/feed`
    - body : 포스팅 내용
    - Authorization 헤더 : API 호출 인증
- 시스템의 개략적 형태
    ![IMG_8702](https://github.com/user-attachments/assets/c1bc1c0e-58b0-45a9-a8bb-37c9c13fbf8c)
    
    1. 사용자가 POST api를 사용해서 포스팅을 올린다.
    2. 로드 밸런서가 트래픽을 웹 서버들로 분산한다.
    3. 웹 서버가 HTTP 요청을 내부 서비스로 중계한다.
        
        (1) 포스팅 저장 서비스(post service) : 새 포스팅을 데이터베이스와 캐시에 저장한다.
        
        (2) 포스팅 전송 서비스(fanout service) : 새 포스팅을 친구의 뉴스 피드에 푸시(push)한다. 뉴스 피드 데이터는 캐시에 보관하여 빠르게 읽어갈 수 있도록 한다.
        
        (3) 알림 서비스(notification service) : 친구들에게 새 포스팅 올라왔음을 알리는 푸쉬 알림 역할을 담당한다.
        

### 2. 뉴스 피드 생성

- 뉴스 피드는 모든 친구의 포스팅을 시간 흐름 역순으로 모아서 만든다고 가정한다.
- API : `GET /v1/me/feed`
    - Authorization 헤더 : API 호출 인증
- 시스템의 개략적 형태
    
    ![IMG_8703](https://github.com/user-attachments/assets/2b414701-b154-49bc-9f20-f84e2096d528)

    
    1. 사용자는 GET api를 이용해서 뉴스 피드 읽기를 요청한다.
    2. 로드 밸런서가 트래픽을 웹 서버들로 분산한다.
    3. 웹 서버가 HTTP 요청을 내부 뉴스 피드 서비스로 보낸다.
    4. 뉴스 피드 서비스 : 캐시에서 뉴스 피드를 가져온다.
    5. 뉴스 피드 캐시 : 뉴스 피드를 랜더링할 때 필요한 피드 ID를 보관하고 있다.
    

## ✅ 3단계. 상세 설계

이제 두 설계에 대해 상세히 살펴보자.

### 1. 피드 발행 흐름 상세 설계

웹 서버와 포스팅 전송(fanout) 서비스에 초점을 맞춰 설계하도록 하겠다.
![IMG_8704](https://github.com/user-attachments/assets/4b3d0106-7d1f-40cc-a0ac-0febd9980a62)


**웹서버**

웹 서버는 클라이언트와 통신할 뿐만 아니라 인증이나 처리율 제한 등의 기능도 수행한다. 예를 들어 앞서 말한 Authorization 헤더에서 인증 토큰을 체크해서 인증된 사용자만 포스팅에 접근할 수 있게 한다. 또한, 스팸이나 유해한 콘텐츠를 막기 위해 특정 기간 동안 한 사용자가 올릴 수 있는 포스팅의 수 제한을 두어야 한다.

**포스팅 전송(fanout) 서비스**

포스팅 전송(fanout)은 어떤 사용자가 새 포스팅을 그 사용자와 친구 관계에 있는 모든 사용자에게 전달하는 과정이다. 여기서 두 가지 모델을 사용할 수 있는데, 하나는 쓰기 시점 팬아웃(다른 말로 푸시push) 모델이고 다른 하나는 읽기 시점에 팬아웃(다른 말로 풀pull) 모델이다.

**✏️ 쓰기 시점 팬아웃(push) 모델**

- 새로운 포스팅을 기록하는 시점에 뉴스 피드 갱신
- 포스팅 완료되면 바로 해당 사용자의 캐시에 해당 포스팅을 기록하는 것
- 장점
    - 뉴스 피드 실시간 갱신
    - 친구 목록에 있는 사용자에게 즉시 전송됨
    - 뉴스 피드를 읽는 데 드는 시간이 짧음
- 단점
    - 친구가 많은 사용자의 경우 피드 갱신에 많은 시간이 소요될 수 있음 → 핫키(hotkey)문제
    - 서비스를 자주 사용하지 않는 사용자의 피드까지 갱신해야 하므로 컴퓨팅 자원 낭비
    

**✏️ 읽기 시점 팬아웃(pull) 모델**

- 사용자가 피드를 읽는(로딩하는) 시점에 뉴스 피드 갱신
- 요청 기반(on-demand) 모델
- 장점
    - 비활성화된 사용자의 경우 이 모델이 유리 (로그인하기까지 어떤 컴퓨팅 자원도 소모X)
    - 데이터를 친구 각각에 푸시하는 작업 필요 X → 핫키 문제 X
- 단점
    - 뉴스 피드 읽는데 많은 시간 소요될 수 있음

본 설계안은 두 가지 방식을 결합하였다. 뉴스 피드를 빠르게 가져오는 것은 아주 중요하므로 대부분의 사용자에 대해서는 푸시 모델을 사용한다. 친구가 아주 많은 사용자만 예외로 풀 모델을 사용하여 시스템 과부하를 방지할 것이다. 아울러 안정 해시(consistent hashing)을 통해 요청과 데이터를 보다 고르게 분산하여 핫키 문제를 줄여볼 것이다. 

팬아웃 서비스 부분만 따로 자세히 살펴보자.

![IMG_8705](https://github.com/user-attachments/assets/caa4df61-0d8c-43d0-9ddb-5d65e9343cda)


1. 그래프 데이터 베이스에서 친구 ID 목록을 가져온다. 
2. 사용자 정보 캐시에서 친구들의 정보를 가져온다. (친한친구, 숨김처리 등 예외 처리 필요) (없으면 데이터베이스에서 가져오기)
3. 친구 목록과 새 스토리의 포스팅 ID를 메세지 큐에 넣는다.
4. 팬아웃 작업서버(포스팅 전송 작업서버)가 메시지 큐에서 데이터를 꺼내어 뉴스 피드 데이터를 뉴스 피드 캐시에 넣는다.
    
    뉴스피드 캐시에 넣는 데이터는 <포스팅 ID, 사용자 ID>의 순서쌍 형태로, 뉴스피드 캐시는 맵핑 테이블이라고 볼 수 있다. 데이터 전체를 저장하면 메모리 요구량이 지나치게 늘어날 수 있기 때문에 ID만 보관한다.
    
    또한, 캐시 크기에 제한을 두어 최신순으로 관리한다. 왜냐하면 사용자가 보려하는 것은 최신 스토리므로 캐시 미스가 일어날 확률이 낮기 때문이다.
    

### 2. 피드 읽기 흐름 상세 설계

![IMG_8706](https://github.com/user-attachments/assets/b5df8fe7-c71d-488f-b8e6-a8ab4b79e4d6)

1. 뉴스피드 서비스는 뉴스피드 캐시에서 포스팅 ID 목록을 가져온다.
2. 뉴스 피드에 노출되어야하는 내용을 사용자 캐시와 포스팅 캐시에서 가져와 뉴스 피드를 만든다.
3. 생성된 뉴스 피드를 JSON 형태로 클라이언트에게 보낸다. 클라이언트는 해당 피드를 렌더링한다.

### 3. 캐시 구조

뉴스 피드 시스템의 핵심 컴포넌트는 캐시다. 캐시는 아래와 같은 계층 구조로 만들 수 있다.

![IMG_8707](https://github.com/user-attachments/assets/a3b01730-e825-4b41-8864-554319a9c0c9)


## ✅ 4단계. 마무리

추가적으로 수직적 규모 확장 vs. 수평적 규모 확장이나 SQL vs. NoSQL 등 데이터 베이스 규모 확장에 대해 다루어볼 수 있을 것이다.
그리고 가능한 한 많은 데이터를 캐시할 방법, 메시지 큐를 사용하여 컴포넌트 사이의 결합도를 낮추는 방법, 트래픽이 몰리는 시간대의 QPS 등에 대해 다뤄볼 수 있을 것이다.

## 📌 정리

오늘 뉴스 피드 시스템 설계 방법에 대해 배워봤다.

**뉴스 피드 시스템 개요**

- 뉴스 피드는 사용자의 홈페이지 중앙에 지속적으로 업데이트되는 스토리들로, 친구들의 활동과 관심사를 보여줌⁠⁠
- 핵심 기능은 **새로운 스토리 올리기**와 **친구들의 스토리 보기⁠**
**피드 발행 및 읽기 프로세스**

- 피드 발행은 포스팅 저장, 포스팅 전송(fanout), 알림 서비스로 구성됨⁠⁠
- 피드 읽기는 캐시에서 뉴스 피드를 가져오는 과정으로 이루어짐⁠

**피드 발행 - 팬아웃 모델**

- 쓰기 시점 push 모델은 실시간 갱신의 장점을 가지고 있고, 읽기 시점 pull 모델은 불필요한 데이터 업데이트를 하지 않아도 된다는 장점을 가지고 있다.
- 본 설계안에서는 쓰기 시점 팬아웃(push) 모델과 읽기 시점 팬아웃(pull) 모델을 결합하여 사용⁠⁠
- 대부분의 사용자에게는 push 모델을, 친구가 많은 사용자에게는 pull 모델을 적용하여 시스템 과부하 방지⁠

**캐시 구조의 중요성**

- 뉴스 피드 시스템의 핵심 컴포넌트는 캐시로, 계층 구조로 설계됨⁠
