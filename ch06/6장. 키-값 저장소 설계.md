**키-값 저장소 = 키-값 데이터베이스 (NoSQL DB)**
- AWS DynamoDB, memcached, Redis 등

- 단일 서버 키-값 저장소 - 모든 데이터를 메모리 안에 두어야한다. - 데이터의 크기가 메모리 크기를 초과하면 불가능  
➡️ 분산 키-값 저장소 사용

**CAP 정리** - C, A, P 세 가지 중에 어떤 두 가지를 충족하려면, 나머지 하나는 반드시 희생되어야한다.
**C: Consistency**
- 데이터 일관성: 분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 보게 되어야한다. 
**A: Availability**
- 가용성: 분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생하더라도 항상 응답을 받을 수 있어야한다.
**P: Partition Tolerance**
- 파티션 감내: 네트워크에 파티션(통신 장애)이 생기더라도 시스템은 계속 동작해야한다.  
➡️ CP, AP, (CA) 시스템 존재 - 네트워크 장애 시, 시스템은 반드시 정상동작해야하므로 CA는 존재하지 않는다.  
➡️ 즉, 네트워크 장애가 생기면, 데이터 일관성과 가용성 사이에서 지킬 것을 선택해야한다.
- 데이터 일관성을 지키기 위해서는 상황이 해결될 때까지 오류를 리턴해야한다.
- 가용성을 지키기 위해서는 데이터가 맞지 않는 옛날 데이터라도 리턴해야한다.(읽기 연산 시)

**분산 키-값 저장소 구현을 위해 필요한 기술**
1. 데이터 파티션
- 안정 해시 기술 이용
  - 장점1: 규모 확장 자동화 - 시스템 부하에 따라 서버가 자동으로 추가되거나 삭제되도록 만들 수 있다.
  - 장점2: 다양성 - 각 서버의 용량에 맞게 가상 노드의 수를 조정할 수 있다.
2. 데이터 다중화
- 데이터를 N개 서버에 비동기적으로 다중화
- 안정 해시 기술 이용
- 키를 해시 링 위에 배치한 후, 그 지점으로부터 시계 방향으로 링을 순회하면서 만나는 첫 N개의 서버에 데이터 사본 보관
3. 데이터 일관성
- 동기화
- 정족수 합의 프로토콜 - 읽기/쓰기 연산 모두에 일관성 보장
- N: 사본 개수, W: 쓰기 연산에 대한 정족수(W개의 서버로부터 쓰기 연산이 성공했다는 응답을 받아야한다.), R: 읽기 연산에 대한 정족수(R개의 서버로부터 읽기 연산이 성공했다는 응답을 받아야한다.)
- 중재자: proxy
- W+R>N : 강한 일관성 보장 - 일관성을 보증할 최신 데이터를 가진 노드가 최소한 하나는 겹칠 것이기 때문이다. - 클라이언트는 낡은 데이터를 보지 못함.

- 강한 일관성: 클라이언트는 낡은 데이터를 보지 못함. - 모든 사본에 현재 쓰기 연산의 결과가 반영될 때까지 읽기/쓰기를 금지한다. - 가용성 감소
- 약한 일관성: 낡은 데이터가 있는 사본이 있을 수 있음.
- 최종 일관성: 낡은 데이터가 있는 사본이 있을 수 있지만, 최종 사본에는 최신 데이터가 있음.

비 일관성 해소 기법: 데이터 버저닝
- 데이터에 버전 부여, 벡터 시계[서버 번호, 데이터 버전] 활용
- 벡터 시계 사용법: 새로운 버전의 데이터가 쓰이는 경우, 버전이 낮은 데이터가 이 서버에 있다면 버전 update, 해당 데이터가 이 서버에 아예 없다면 버전 1로 create
  - 단점1: 클라이언트에서 구현 복잡(클라이언트에서 개발해야함.)
  - 단저2: [서버 번호, 데이터 버전] 쌍의 개수 급증 - 데이터 많아져 효율성 감소

3. 장애 처리
- 장애 감지: 두 대 이상의 서버가 서버A의 장애를 보고하면, 장애가 발생했다고 간주
  - 멀티캐스팅 채널 구축
  - 가십 프로토콜(분산형 장애 감지 솔루션): 다른 서버에 대한 멤버십 목록을 갖고 있고, 다른 서버로부터 박동 카운터를 받아서 갱신, 자기도 다른 서버로 박동 카운터를 보냄. 박동 카운터를 받은 시간을 계산해서 어느정도가 넘으면 장애가 발생했다고 감지
    - 엄격한 정족수: 읽기, 쓰기 연산 금지
    - 일시적 장애 처리 - 느슨한 정족수: 쓰기 연산을 수행할 건강한 서버와 읽기 연산을 수행할 건강한 서버를 해시 링에서 골라서 임시로 쓰기 연산을 처리하고 단서를 남겨둔다. - 임시 위탁 기법
    - 영구적 장애 처리 - 반-엔트로피 프로토콜 구현 - 사본들을 비교하여 최신 버전으로 갱신 - 사본 간의 일관성이 망가진 상태를 탐지하고 전송 데이터의 양을 줄이기 위해서 **머클 트리** 사용
   
    - 머클 트리 - 자식 노드들의 레이블로부터 계산된 해시값을 레이블로 붙여두는 트리 - 대규모 자료구조의 내용을 효과적이면서도 보안상 안전한 방법으로 검증할 수 있다.
      - 버킷의 해시값을 구하고, 상향식으로 이진 트리를 구성하며 - 루트값을 비교한다. - 루트값이 다르면 데이터 일관성이 깨진 것 -> 내려오면서 어디에서 데이터 일관성이 깨졌는지 알 수 있다.

**시스템 아키텍처 다이어그램**
구조: 클라이언트 🔄 중재자 🔄 노드들(서버들)
- 쓰기: 클라이언트로부터의 쓰기 요청이 커밋 로그 파일에 기록 ➡️ 데이터를 메모리 캐시에 기록 / 메모리 캐시가 다 찼거나 기록할 수 없다면 디스크에 기록
- 읽기: 클라이언트로부터 읽기 요청을 수신 ➡️ 메모리 캐시에 있다면 바로 반환 / 없다면 디스크에서 조회해서 반환
  - 디스크에 있는 여러 테이블에서 어디에 키가 있는지 찾을 때, 보편적으로 블룸 필터를 사용
  - 블룸필터: 원소가 집합에 속하는지 여부를 검사하는데 사용되는 확률적 자료 구조 (https://ko.wikipedia.org/wiki/%EB%B8%94%EB%A3%B8_%ED%95%84%ED%84%B0)
  
